/*
  Chimera compiler - Common Intermediate Language (CIL) code generator.
  Copyright (C) 2013 Ariel Ortiz, ITESM CEM
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* 
 * Siegfried Paul Keller Schippner A01375356
 * José Javier Rodríguez Mota A01372812
 * Ana Paula Mejía Quiroz A01371880
 */

using System;
using System.Text;
using System.Collections.Generic;

namespace Chimera {

    class CILGenerator {

        FunctionTable params;

        public SymbolTable globalSymbolTable = new SymbolTable();
        public SymbolTable globalFunctionTableTypes = new SymbolTable();
        public FunctionTable globalFunctionTable = new FunctionTable();
        public SymbolTable globalConstTable = new SymbolTable();
        public IDictionary<string, SymbolTable> localSymbolTables = new SortedDictionary<string, SymbolTable>();
        public IDictionary<string, SymbolTable> localConstTables = new SortedDictionary<string, SymbolTable>();
        public IDictionary<string, SymbolTable> functionParamTables = new SortedDictionary<string, SymbolTable>();
        public SymbolTable currentLocalSymbolTable = new SymbolTable();
        public SymbolTable currentLocalConstTable = new SymbolTable();
        public SymbolTable currentFunctionParamTable = new SymbolTable();

        int labelCounter = 0;
        bool insideFunction = false;
        string endLoop = "";
        string ifLabel = "";

        //-----------------------------------------------------------
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        }    

        //-----------------------------------------------------------
        static readonly IDictionary<Type, string> CILTypes =
            new Dictionary<Type, string>() {
                { Type.BOOL, "bool" },
                { Type.INT, "int32" }
                { Type.STR, "someStrThingi" }
            };

        public CILGenerator(Object[] tables) {
            //assign tables given by Semantic Analyzer
            globalSymbolTable = tables[0];
            globalFunctionTable = tables[1];
            globalConstTable = tables[2];
            localSymbolTables = tables[3];
            localConstTables = tables[4];
            functionParamTables = tables[5];
            currentLocalSymbolTable = tables[6];
            currentLocalConstTable = tables[7];
            currentFunctionParamTable = tables[8];

            globalFunctionTable.Add("WrInt");
            globalFunctionTable.Add("WrStr");
            globalFunctionTable.Add("WrBool");
            globalFunctionTable.Add("WrLn");
            globalFunctionTable.Add("RdInt");
            globalFunctionTable.Add("RdStr");
            globalFunctionTable.Add("AtStr");
            globalFunctionTable.Add("LenStr");
            globalFunctionTable.Add("CmpStr");
            globalFunctionTable.Add("CatStr");
            globalFunctionTable.Add("LenLstInt");
            globalFunctionTable.Add("LenLstStr");
            globalFunctionTable.Add("LenLstBool");
            globalFunctionTable.Add("NewLstInt");
            globalFunctionTable.Add("NewLstStr");
            globalFunctionTable.Add("NewLstBool");
            globalFunctionTable.Add("IntToStr");
            globalFunctionTable.Add("StrToInt");
        }

        public string Visit(Program node) {
            return "//Code generated by The Chimera Compiler.\n"
            + ".assembly 'chimera' {}\n"
            + ".assembly extern 'chimeralib' {}\n"
            + ".class public 'ChimeraProgram' extends "
            + "['mscorlib']'System'.'Object' {\n"
            + VisitChildren(node);
            + "}\n"
            //Visit((dynamic) node[0]);
            //Visit((dynamic) node[1]);
        }

        public string Visit(Expression node){
            return VisitChildren(node);
        }

        public string Visit(DeclarationList node) {
            return VisitChildren(node);
        }

        public string Visit(StatementList node) {
            return VisitChildren(node);
        }

        public string Visit(ProcDeclaration node) {
            localscope = node[0].AnchorToken.Lexeme;
            currentLocalConstTable = new SymbolTable();
            currentLocalSymbolTable = new SymbolTable();
            currentFunctionParamTable = new SymbolTable();
            Visit((dynamic) node[1]);
            globalSymbolTable[localscope] = Visit((dynamic) node[2]);
            Visit((dynamic) node[3]);
            Visit((dynamic) node[4]);
            Visit((dynamic) node[5]);//ProcStatement
            globalFunctionTable[localscope] = currentFunctionParamTable.Size();
            localSymbolTables.Add(localscope, currentLocalSymbolTable);
            localConstTables.Add(localscope, currentLocalConstTable);
            localscope = null;
            return Type.VOID;
        }
        public string Visit(ProcParam node) {
            return VisitChildren(node);
        }
        public string Visit(ProcType node) {
            foreach(var n in node) {
                return Visit((dynamic) n);
            }
            return Type.VOID;
        }
        public string Visit(ProcConst node) {
            VisitChildren(node);
            return Type.VOID;
        }

        public string Visit(ProcVar node) {
            VisitChildren(node);
            return Type.VOID;
        }

        public string Visit(ProcStatement node) {
            VisitChildren(node);
            return Type.VOID;
        }

        public string Visit(CallStatement node){
            //check if function exists in tables
            var name = node.AnchorToken.Lexeme;
            if(globalFunctionTable.Contains(name)){
                //call function
                if(globalFunctionTableTypes.Contains(name)){
                    return globalFunctionTableTypes[name];
                }
                if(globalSymbolTable.Contains(name)){
                    return globalSymbolTable[name];
                }
                return Type.VOID;
            }else{
                throw new SemanticError("Function/Procedure " + name + "not declared!", node.AnchorToken);
            }
        }

        public string Visit(ParamDeclaration node) {
            var idList = node[0];
            var type = Visit((dynamic)node[1]);
            foreach( var n in idList) {
                var name = n.AnchorToken.Lexeme;
                if (currentFunctionParamTable.Contains(name)) {
                    throw new SemanticError(
                    "Parameter " + name 
                    + " already exists in function "+localscope,                   
                    n.AnchorToken);
                }
                currentFunctionParamTable[name] = type;
            }
            return Type.VOID;
        }

        //types
        //-----------------------------------------------------------
        public string Visit(True node) {
            return "\tldc.i4 1\n";
        }

        //-----------------------------------------------------------
        public string Visit(False node) {
            return "\tldc.i4 0\n";
        }

        public string Visit(If node){
            var elseBody = GenerateLabel();
            var prevEndIf = ifLabel;
            ifLabel = GenerateLabel();
            var result = Visit(((dynamic) node[0]))
            + "ldc.i4.1\n"
            + "bne.un '" + elseBody + "'\n")
            + Visit(((dynamic) node[1]))
            + "br " + ifLabel + "\n"
            + "'" + elseBody + "':\n"
            + Visit(((dynamic) node[2]))
            + "'" + ifLabel + "':\n";

            ifLabel = prevEndIf;
            return result;
        }

        public string Visit(ElseIf node){
            var label = GenerateLabel();
            return Visit(((dynamic) node[0]))
            + "ldc.i4.1\n"
            + "bne.un '" + label + "'\n"
            + Visit(((dynamic) node[1]))
            + "'" + label + "':\n";
        }

        public string Visit(Else node){
            return VisitChildren(node);
        }

        public string Visit(Then node){
            return VisitChildren(node);
        }

        public string Visit(Assignment node){
            if(params.Contains(node.AnchorToken.Lexeme)){
                return VisitChildren(node) + "\tstarg.s" + params[node.AnchorToken.Lexeme] + "\n";
            }else if(localSymbolTables.Contains(node.AnchorToken.Lexeme)){
                return VisitChildren(node) + "\tstloc '" + node.AnchorToken.Lexeme + "'\n";
            }else{
                return VisitChildren(node) + "\tstsfld int32 'ChimeraProgram'::'" + node.AnchorToken.Lexeme + "'\n";
            }
        }

        public string Visit(Loop node){
            var startLoop = GenerateLabel();
            var currentEndLoop = GenerateLabel();
            endLoop = currentEndLoop;
            return = "\t"
            + startLoop + ":\n"
            + VisitChildren(node) + "\n"
            + "br " + startLoop;
            + currentEndLoop + "\n";
        }

        public string Visit(For node){
            return VisitChildren(node);
        }

        public string Visit(Do node){
            return VisitChildren(node);
        }

        public string Visit(List node) {
            Type expectedType = Visit((dynamic) node[0]);
            foreach( var n  in node) {
                Type type = Visit((dynamic) n);
                if (type != expectedType) {
                    throw new SemanticError("Expected "+expectedType+" as return but got instead "+ type, node.AnchorToken);
                }
            }
            switch (expectedType) {
                case Type.INT:
                    return Type.LIST_INT;
                case Type.BOOL:
                    return Type.LIST_BOOL;
                case Type.STR:
                    return Type.LIST_STR;
                default:
                    return Type.VOID;
            };
        }

        public string Visit(ChimeraType node){
            return typeMapper[node.AnchorToken.Category];
            //VisitChildren(node);
            //return Type.VOID;
        }

        public string Visit(ListType node){
            Type type = Type.VOID;
            if (node[0] is ChimeraType) {
                type = Visit((dynamic) node[0]);
            } 
            switch (type) {
                case Type.INT:
                    return Type.LIST_INT;
                case Type.BOOL:
                    return Type.LIST_BOOL;
                case Type.STR:
                    return Type.LIST_STR;
                default:
                    return Type.VOID;
            }
        }

        public string Visit(Return node){
            return VisitChildren(node) + "\tret\n";
        }

        public string Visit(Exit node){
            VisitChildren(node);
            return "brfalse " + endLoop + "\n";
        }

        public string Visit(IntLiteral node){
            var value = Convert.ToInt32(node.AnchorToken.Lexeme);
            if(value <= 8){
                return "\tldc.i4." + value + "\n";
            }else if(value <= 127){
                return "\tldc.i4.s " + value + "\n";
            }else{
                return "\tldc.i4 " + value + "\n";
            }
        }

         public string Visit(StrLiteral node){
            return "ldstr " + node.AnchorToken.Lexeme + "\n";
        }

        public string Visit(VarDeclaration node){
            return VisitChildren(node);
        }

        public string Visit(Var node) {
            var result = "";
            if(insideFunction){
                foreach(var n in node[0]){
                    result = result + "\t.locals init (int32 '" + n.AnchorToken.Lexeme + "')\n";
                    localSymbolTables.Add(n.AnchorToken.Lexeme);
                }
            }else{
                foreach(var n in node[0]){
                    result = result + "\t.field public static int32 '" + n.AnchorToken.Lexeme + "'\n";
                    globalSymbolTable.Add(n.AnchorToken.Lexeme);
                }
            }
            return result;
        }

        public string Visit(ConstDeclaration node) {
            if(node.AnchorToken.Category == TokenCategory.ASSIGN){
                var varName = node[0].AnchorToken.Lexeme;
                var type = Visit((dynamic) node[1]);
                if (localscope) {
                    if (currentLocalConstTable.Contains(varName)) {
                        throw new SemanticError("Duplicated constant: " + varName, node[0].AnchorToken);
                    }
                    currentLocalConstTable[varName] = type;
                } else {
                    if (globalConstTable.Contains(varName)) {
                        throw new SemanticError("Duplicated constant: " + varName, node[0].AnchorToken);
                    } else if (globalSymbolTable.Contains(varName)) {
                        throw new SemanticError("Constant and variable cannot have the same name: " + varName, node[0].AnchorToken);
                    } else  {
                        globalSymbolTable[varName] = type;
                    }
                }
            }
            VisitChildren(node);
            return Type.VOID;
        }

        public string Visit(Identifier node){
            if(params.Contains(node.AnchorToken.Lexeme)){
                return "\tldarg." + params[node.AnchorToken.Lexeme] + "\n";
            }else if(localSymbolTables.Contains(node.AnchorToken.Lexeme)){
                return "\tldloc '" + node.AnchorToken.Lexeme + "'\n";
            }else{
                return "\tldsfld int32 'ChimeraProgram'::'" + node.AnchorToken.Lexeme + "'\n";
            }
        }

        //operators
        //-----------------------------------------------------------
        void VisitBinaryOperator(string op, Node node, Type type) {
            if (Visit((dynamic) node[0]) != type || 
                Visit((dynamic) node[1]) != type) {
                throw new SemanticError(
                    String.Format(
                        "Operator {0} requires two operands of type {1}",
                        op, 
                        type),
                    node.AnchorToken);
            }
        }

        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        public string Visit(And node){
            VisitBinaryOperator("and",node, Type.BOOL);
            return Type.BOOL;
        }

        public string Visit(Or node){
            VisitBinaryOperator("or",node, Type.BOOL);
            return Type.BOOL;
        }

        public string Visit(Xor node){
            VisitBinaryOperator("xor",node, Type.BOOL);
            return Type.BOOL;
        }

        public string Visit(Equal node){
            VisitBinaryOperator("=",node, Type.INT);
            return Type.BOOL;
        }

        public string Visit(BoolIneq node){//also for int ineq
            if(Visit((dynamic) node[0]) == Type.INT){
                VisitBinaryOperator("<>",node, Type.INT);
            }else{
                VisitBinaryOperator("<>",node, Type.BOOL);
            }
            return Type.BOOL;
        }

        public string Visit(Less node){
            VisitBinaryOperator("<",node,Type.INT);
            return Type.BOOL;
        }

        public string Visit(More node){
            VisitBinaryOperator(">",node,Type.INT);
            return Type.BOOL;
        }

        public string Visit(LessEq node){
            VisitBinaryOperator("<=",node,Type.INT);
            return Type.BOOL;
        }

        public string Visit(MoreEq node){
            VisitBinaryOperator(">=",node,Type.INT);
            return Type.BOOL;
        }

        public string Visit(Plus node){
            VisitBinaryOperator("+",node,Type.INT);
            return Type.INT;
        }

        public string Visit(Neg node){//also for substraction?
            if(node[1] != null){//two operands -> substraction
                VisitBinaryOperator("-",node,Type.INT);
            }else{//one operand -> negation
                if(Visit((dynamic) node[0]) != Type.INT){
                    throw new SemanticError(
                        String.Format(
                            "Operator - requires one operand of type {1}",
                            Type.INT),
                        node.AnchorToken);
                }
            }
            return Type.INT;
        }

        public string Visit(Mul node){
            VisitBinaryOperator("*",node,Type.INT);
            return Type.INT;
        }

        public string Visit(Div node){
            VisitBinaryOperator("div",node,Type.INT);
            return Type.INT;
        }

        public string Visit(Rem node){
            VisitBinaryOperator("rem",node,Type.INT);
            return Type.INT;
        }

        public string Visit(Not node){
            if(Visit((dynamic) node[0]) != Type.BOOL){
                throw new SemanticError(
                    String.Format(
                        "Operator not requires one operand of type {1}",
                        Type.BOOL),
                    node.AnchorToken);
            }
            return Type.BOOL;
        }
    }
}
